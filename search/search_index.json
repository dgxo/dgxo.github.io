{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dog's Roblox Luau Style Guide","text":"<p>This style guide aims to unify as much Luau code as possible that I write, and others edit, under the same style and conventions.</p> <p>This guide is designed after the Roblox Lua Style Guide. I disagreed with some guidelines, so I made my own.</p> <p>Where the term file is mentioned, it can refer to any kind of <code>Script</code>.</p>"},{"location":"#guiding-principles","title":"Guiding Principles","text":"<ul> <li>The purpose of a style guide is to avoid arguments.<ul> <li>There's no one right answer to how to format code, but consistency is important, so we agree to accept this one, somewhat arbitrary standard so we can spend more time writing code and less time arguing about formatting details in the review.</li> </ul> </li> <li>Optimize code for reading, not writing.<ul> <li>You will write your code once. Many people will need to read it, from other developers, to any one else that touches the code, to you when you come back to it in six months.</li> </ul> </li> <li>Avoid magic, such as surprising or dangerous Luau features:<ul> <li>Magical code is really nice to use, until something goes wrong. Then no one knows why it broke or how to fix it.</li> <li>Metatables are a good example of a powerful feature that should be used with care.</li> </ul> </li> <li>Be consistent with idiomatic Luau when appropriate.</li> </ul>"},{"location":"#file-structure","title":"File Structure","text":"<p>Files should consist of these things (if present) in order:</p> <ol> <li>An optional comment with the author's name and a brief description, if it's not obvious what the file does</li> <li>Services used by the file, using <code>GetService</code><ul> <li>Services should never be fetched anywhere else in the file, or by indexing <code>game</code></li> </ul> </li> <li>Module imports, using <code>require</code><ul> <li>Use the name of the module for its variable name</li> </ul> </li> <li>Constants</li> <li>Variables and functions</li> <li>(if module) The object the module returns</li> <li>(if module) A return statement</li> </ol>"},{"location":"#requires","title":"Requires","text":""},{"location":"#general","title":"General","text":"<ul> <li>All require calls must be at the top of a file, making dependencies static.</li> <li>Files with a lot of requires should have them be sorted alphabetically, by module name.</li> </ul>"},{"location":"#requiring-libraries","title":"Requiring Libraries","text":"<p>Libraries are projects which define an API for external consumers to use, typically by providing a top-level table which requires other modules. Libraries will typically provide a structured public API composed from internal modules. This allows libraries to have stable interfaces even when internal details may change, and can be used both for sharing code as well as for organizing one's own code.</p> <ul> <li>Library internals should require their public and private modules directly, eg. <pre><code>-- in MyLibrary/Foo.lua\nlocal MyLibrary = script.Parent\nlocal MyModule = require(MyLibrary.MyModule)\n</code></pre></li> <li>Consumers of libraries should require the API definition and then path to a public module, eg. <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal MyLibrary = require(ReplicatedStorage.MyLibrary)\nlocal MyModule = MyLibrary.MyModule\n</code></pre></li> </ul>"},{"location":"#example","title":"Example","text":"<p>For a project that looks like the following: <pre><code>MyProject\n|- FooBar\n| |- Foo.lua\n| |- Bar.lua\n|- MyClass.lua\n|- Packages\n| |- Baz.lua\n| | |- Bazifyer.lua\n| | |- UnBazifyer.lua\n</code></pre> MyClass should define the following import block: <pre><code>-- 1. A definition of a common ancestor.\n-- Use a relative path to make sure your project works in multiple locations!\nlocal MyProject = script.Parent\n\n-- 2. A block of all imported packages.\n-- Baz is a library we depend on in our project, so we require its API directly...\nlocal Baz = require(MyProject.Packages.Baz)\n\n-- 3. A block for definitions derived from packages.\n-- ...and then access its members through that API. These are simple so we don't need to break them down.\nlocal Bazifyer = Baz.Bazifyer\nlocal UnBazifyer = Baz.UnBazifyer\n\n-- 4. A block for modules imported from the same project.\n-- Defining the path to FooBar separately makes it faster to write and for others to read!\nlocal FooBar = MyProject.FooBar\nlocal Foo = require(FooBar.Foo)\nlocal Bar = require(Foobar.Bar)\n</code></pre></p>"},{"location":"#metatables","title":"Metatables","text":"<p>Metatables are an incredibly powerful Luau feature that can be used to overload operators, implement prototypical inheritance, and tinker with limited object lifecycle. Ideally, metatables should be limited to a couple of cases: - Implementing prototype-based classes - Guarding against typos - Using a table as a 'backup' in case a table doesn't have the specified key</p>"},{"location":"#prototype-based-classes","title":"Prototype-based classes","text":"<p>There are multiple ways of defining classes in Lua. The method described below is recommended because it takes advantage of Luau's typing system. Providing a strongly-typed class definition helps developers use and improve your class by documenting its expected use, and allowing analysis tools and IDEs to warn against possible bugs when inconsistencies are detected.</p> <p>First up, we create a regular, empty table: <pre><code>local MyClass = {}\n</code></pre> Next, we assign the __index member on the class back to itself. This is a handy trick that lets us use the class's table as the metatable for instances as well.</p> <p>When we construct an instance, we'll tell Luau to use our __index value to find values that are missing in our instances. It's sort of like prototype in JavaScript, if you're familiar. <pre><code>MyClass.__index = MyClass\n</code></pre> In order to support strict type inference we are describing the shape of our class. This introduces some redundancy as we specify class members twice (once in the type definition, once as we build the actual instance), but warnings will be flagged if the two definitions fall out of sync with each other. <pre><code>-- Export the type if you'd like to use it outside this module\nexport type ClassType = typeof(setmetatable(\n    {} :: {\n        property: number,\n    },\n    MyClass\n))\n</code></pre> Next, we create a default constructor for our class and assign the type definition from above to its return value (self). <pre><code>-- The default constructor for our class is called `new` by convention.\nfunction MyClass.new(property: number): ClassType\n    local self = {\n        -- Define members of the instance here, even if they're `nil` by default.\n        property = property,\n    }\n\n    -- Tell Luau to fall back to looking in MyClass.__index for missing fields.\n    setmetatable(self, MyClass)\n\n    return self\nend\n</code></pre> We can also define methods that operate on instances. Prior to Luau's type analysis capabilities, popular convention has suggested using a colon (<code>:</code>) for methods. But in order to help the type checker understand that <code>self</code> has type <code>ClassType</code>, we use the dot (<code>.</code>) style of definition which allows us to specify the type of <code>self</code> explicitly. These methods can still be invoked on the resulting instances with a colon as expected.</p> <p>In the future, Luau will be able to understand the intended type of <code>self</code> without any extra type annotations. <pre><code>function MyClass.addOne(self: ClassType)\n    self.property += 1\nend\n</code></pre> At this point, our class is ready to use!</p> <p>We can construct instances and start tinkering with it: <pre><code>local instance = MyClass.new(0)\n\n-- Properties on the instance are visible, since it's just a table:\nprint(tostring(instance.property)) -- \"0\"\n\n-- Methods are pulled from MyClass because of our metatable:\ninstance:addOne()\nprint(tostring(instance.property)) -- \"1\"\n</code></pre> Further additions you can make to your class as needed: - Introduce a <code>__tostring</code> metamethod to make debugging easier - Define quasi-private members using two underscores as a prefix - Add a method to check type given an instance, like: <pre><code>function MyClass.isMyClass(instance)\n    return getmetatable(instance).__index == MyClass\nend\n</code></pre></p>"},{"location":"#guarding-against-typos","title":"Guarding against typos","text":"<p>Indexing into a table in Luau gives you <code>nil</code> if the key isn't present, which can cause errors that are difficult to trace! Our other major use case for metatables is to prevent certain forms of this problem. For types that act like enums, we can carefully apply an <code>__index</code> metamethod that throws: <pre><code>local MyEnum = {\n    A = \"A\",\n    B = \"B\",\n    C = \"C\",\n}\n\nsetmetatable(MyEnum, {\n    __index = function(self, key)\n        error(string.format(\"%q is not a valid member of MyEnum\",\n            tostring(key)), 2)\n    end,\n})\n</code></pre> Since <code>__index</code> is only called when a key is missing in the table, <code>MyEnum.A</code> and <code>MyEnum.B</code> will still give you back the expected values, but <code>MyEnum.FROB</code> will throw, hopefully helping scripters track down bugs more easily.</p>"},{"location":"#general-punctuation","title":"General Punctuation","text":"<ul> <li>Don't use semicolons <code>;</code>. They are generally only useful to separate multiple statements on a single line, but you shouldn't be putting multiple statements on a single line anyway.</li> </ul>"},{"location":"#general-whitespace","title":"General Whitespace","text":"<ul> <li>Indent with tabs.</li> <li>Keep lines under 100 columns wide, assuming four column wide tabs.</li> <li>Wrap comments to 80 columns wide, assuming four column wide tabs.<ul> <li>This is different than normal code; the hope is that short lines help improve readability of comment prose, but is too restrictive for code.</li> </ul> </li> <li>Don't leave whitespace at the end of lines.<ul> <li>If you're using an editor and it has an auto-trimming function, turn it on!</li> </ul> </li> <li>Add a newline at the end of the file.</li> <li> <p>No vertical alignment!</p> <ul> <li>Vertical alignment makes code more difficult to edit and often gets messed up by subsequent editors. <p>Good:</p> <pre><code>local frobulator = 132\nlocal grog = 17\n</code></pre> <p>Bad:</p> <pre><code>local frobulator = 132\nlocal grog       =  17\n</code></pre></li> </ul> </li> <li> <p>Use a single empty line to express groups when useful. Do not start blocks with a blank line. Excess empty lines harm whole-file readability.     <pre><code>local Foo = require(Common.Foo)\n\nlocal function gargle()\n    -- gargle gargle\nend\n\nFoo.frobulate()\nFoo.frobulate()\n\nFoo.munt()\n</code></pre></p> </li> <li> <p>Use one statement per line. Put function bodies on new lines.     <p>Good:</p> <pre><code>table.sort(stuff, function(a, b)\n    local sum = a + b\n    return math.abs(sum) &gt; 2\nend)\n</code></pre> <p>Bad:</p> <pre><code>table.sort(stuff, function(a, b) local sum = a + b return math.abs(sum) &gt; 2 end)\n</code></pre>     This is especially true for functions that return multiple values. Compare these two statements:     <p></p> <pre><code>Rodux.Store.new(function(state) return state end, mockState, nil)\nRodux.Store.new(function(state) return state, mockState end, nil)\n</code></pre>     It's much easier to spot the mistake (and much harder to make in the first place) if the function isn't on one line.     <p></p> <pre><code>Rodux.Store.new(function(state)\n    return state\nend, mockState, nil)\nRodux.Store.new(function(state)\n    return state, mockState\nend, nil)\n</code></pre></p> <p><p>Exception:</p> <pre><code>-- It's often faster and easier to read multiple guard clause if they are on one line.\nif valueIsInvalid then continue end\n</code></pre></p> </li> <li> <p>Put a space before and after operators, except when clarifying precedence.     <p>Good:</p> <pre><code>print(5 + 5 * 6^2)\n</code></pre> <p>Bad:</p> <pre><code>print(5+5* 6 ^2)\n</code></pre></p> </li> <li>Put a space after each comma in tables and function calls.<ul> <li>Don't include spaces between the brackets and elements of a table. <p>Good:</p> <pre><code>local friends = {\"bob\", \"amy\", \"joe\"}\nfoo(5, 6, 7)\n</code></pre> <p>Bad:</p> <pre><code>local friends = {\"bob\",\"amy\" ,\"joe\"}\nfoo(5,6 ,7)\n</code></pre></li> </ul> </li> <li> <p>When creating blocks, inline any opening syntax elements.     <p>Good:</p> <pre><code>local foo = {\n    bar = 2,\n}\n\nif foo then\n    -- do something\nend\n</code></pre></p> <p><p>Bad:</p> <pre><code>local friends = {\"bob\",\"amy\" ,\"joe\"}\nfoo(5,6 ,7)\n</code></pre> - Avoid putting curly braces for tables on their own line. Doing so harms readability, since it forces the reader to move to another line in an awkward spot in the statement. <p>Good:</p> <pre><code>local foo = {\n    bar = {\n        baz = \"baz\",\n    },\n}\n\nfrob({\n    x = 1,\n})\n</code></pre> <p>Bad:</p> <pre><code>local foo =\n{\n    bar =\n\n    {\n        baz = \"baz\",\n    },\n}\n\nfrob(\n{\n    x = 1,\n})\n</code></pre> <p>Exception:</p> <pre><code>-- In function calls with large inline tables or functions, sometimes it's\n-- more clear to put braces and functions on new lines:\nfoo(\n    {\n        type = \"foo\",\n    },\n    function(something)\n        print(\"Hello,\" something)\n    end\n)\n\n-- As opposed to:\nfoo({\n    type = \"foo\",\n}, function(something) -- How do we indent this line?\n    print(\"Hello,\", something)\nend)\n</code></pre></p> </li> </ul>"},{"location":"#newlines-in-long-expressions","title":"Newlines in Long Expressions","text":"<ul> <li>First, try and break up the expression so that no one part is long enough to need newlines. This isn't always the right answer, as keeping an expression together is sometimes more readable than trying to parse how several small expressions relate, but it's worth pausing to consider which case you're in.</li> <li>It is often worth breaking up tables and arrays with more than two or three keys, or with nested sub-tables, even if it doesn't exceed the line length limit. Shorter, simpler tables can stay on one line though.</li> <li>Prefer adding the extra trailing comma to the elements within a multiline table or array. This makes it easier to add new items or rearrange existing items.</li> <li>Break dictionary-like tables with more than a couple keys onto multiple lines.     <p>Good:</p> <pre><code>local foo = {type = \"foo\"}\n\nlocal bar = {\n    type = \"bar\",\n    phrase = \"hooray\",\n}\n\n-- It's also okay to use multiple lines for a single field\nlocal baz = {\n    type = \"baz\",\n}\n</code></pre> <p>Bad:</p> <pre><code>local stuff = {hello = \"world\", hola = \"mundo\", howdy = \"y'all\", sup = \"homies\"}\n</code></pre></li> <li> <p>Break list-like tables onto multiple lines however it makes sense.</p> <ul> <li>Make sure to follow the line length limit! </li> </ul> <p><pre><code>local libs = {\"roact\", \"rodux\", \"testez\", \"cryo\", \"otter\"}\n\n-- You can break these onto multiple lines, which makes diffs cleaner:\nlocal libs = {\n    \"roact\",\n    \"rodux\",\n    \"testez\",\n    \"cryo\",\n    \"otter\",\n}\n\n-- We can also group them, if grouping has useful information:\nlocal libs = {\n    \"roact\", \"rodux\", \"cryo\",\n\n    \"testez\", \"otter\",\n}\n</code></pre> - For long argument lists or longer, nested tables, prefer to expand all the subtables. This makes for the cleanest diffs as further changes are made. <pre><code>    local aTable = {\n    {\n        aLongKey = aLongValue,\n        anotherLongKey = anotherLongValue,\n    },\n    {\n        aLongKey = anotherLongValue,\n        anotherLongKey = aLongValue,\n    },\n}\n\ndoSomething(\n    {\n        aLongKey = aLongValue,\n        anotherLongKey = anotherLongValue,\n    },\n    {\n        aLongKey = anotherLongValue,\n        anotherLongKey = aLongValue,\n    }\n)\n</code></pre></p> <p>In some situations where we only ever expect table literals, the following is acceptable, though there's a chance automated tooling could change this later. In particular, this comes up a lot in Roact code (<code>doSomething</code> being <code>Roact.createElement</code>). <pre><code>local aTable = {{\n    aLongKey = aLongValue,\n    anotherLongKey = anotherLongValue,\n}, {\n    aLongKey = anotherLongValue,\n    anotherLongKey = aLongValue,\n}}\n\ndoSomething({\n    aLongKey = aLongValue,\n    anotherLongKey = anotherLongValue,\n}, {\n    aLongKey = anotherLongValue,\n    anotherLongKey = aLongValue,\n})\n</code></pre> However, this case is less acceptable if there are any non-tables added to the mix. In this case, you should use the style above. <p>Good:</p> <pre><code>doSomething(\n    {\n        aLongKey = aLongValue,\n        anotherLongKey = anotherLongValue\n    },\n    notATableLiteral,\n    {\n        aLongKey = anotherLongValue,\n        anotherLongKey = aLongValue\n    }\n)\n</code></pre> <p>Bad:</p> <pre><code>doSomething({\n    aLongKey = aLongValue,\n    anotherLongKey = anotherLongValue\n}, notATableLiteral, {\n    aLongKey = anotherLongValue,\n    anotherLongKey = aLongValue\n})\n</code></pre></p> </li> <li> <p>For long expressions try and add newlines between logical subunits. If you're adding up lots of terms, place each term on its own line. If you have parenthesized subexpressions, put each subexpression on a newline.</p> <ul> <li>Place the operator at the beginning of the new line. This makes it clearer at a glance that this is a continuation of the previous line.</li> <li>If you have to need to add newlines within a parenthesized subexpression, reconsider if you can't use temporary variables. If you still can't, add a new level of indentation for the parts of the statement inside the open parentheses much like you would with nested tables.</li> <li>Don't put extra parentheses around the whole expression. This is necessary in Python, but Luau doesn't need anything special to indicate multiline expressions.</li> </ul> </li> <li> <p>For long conditions in <code>if</code> statements, put the condition in its own indented section and place the <code>then</code> on its own line to separate the condition from the body of the <code>if</code> block. Break up the condition as any other long expression.     <p>Good:</p> <pre><code>if\n    someReallyLongCondition\n    and someOtherReallyLongCondition\n    and somethingElse\nthen\n    doSomething()\n    doSomethingElse()\nend\n</code></pre> <p>Bad:</p> <pre><code>if someReallyLongCondition and someOtherReallyLongCondition\n    and somethingElse then\n    doSomething()\n    doSomethingElse()\nend\n\nif someReallyLongCondition and someOtherReallyLongCondition\n        and somethingElse then\n    doSomething()\n    doSomethingElse()\nend\n\nif someReallyLongCondition and someOtherReallyLongCondition\n    and somethingElse then\n        doSomething()\n        doSomethingElse()\nend\n</code></pre></p> </li> </ul>"},{"location":"#if-then-else-expressions","title":"if-then-else expressions","text":"<ul> <li>Use <code>if-then-else</code> expressions over the <code>x and y or z</code> pattern for selecting a value. They're safer, faster and more readable.     <p>Good:</p> <pre><code>local scale = if someCondition then 1 else 2\n</code></pre> <p>Bad:</p> <pre><code>local scale = someCondition and 1 or 2\n</code></pre><ul> <li><code>if</code> expressions require an <code>else</code>. In some cases, we only use <code>someCondition</code> and <code>someObject</code> without the <code>or</code>. It's fine to either leave this as is (it doesn't have the same safety issues) or convert it to <code>if someCondition then someObject else nil</code>.</li> </ul> </li> <li>Don't get carried away trying to fit everything into one statement though. These work best when they comfortably fit on one line.</li> <li>For multiple line <code>if</code> expressions, put the <code>then</code> and <code>else</code> at the start of new lines, each indented once.     <p>Good:</p> <pre><code>local scale = if someReallyLongConditionName or someOtherReallyLongConditionName\n    then 1\n    else 2\n</code></pre> <p>Bad:</p> <pre><code>local scale = if someReallyLongConditionName or someOtherReallyLongConditionName then 1\n    else 2\n\nlocal scale = if someReallyLongConditionName or someOtherReallyLongConditionName\n    then 1 else 2\n\nlocal scale = if someReallyLongConditionName or someOtherReallyLongConditionName then\n    1 else 2\n</code></pre></li> <li>If the <code>if</code> expression won't fit on three lines, convert it to a normal <code>if</code> statement.     <p>Good:</p> <pre><code>local scale\nif\n    someReallyLongConditionName\n    or someOtherReallyLongConditionName\nthen\n    scale = Vector2.new(1, 1) + someVectorOffset\n        + someOtherVector\nelse\n    scale = Vector2.new(1, 1) + someNewVectorOffset\n        + someNewOtherVector\nend\n</code></pre> <p>Bad:</p> <pre><code>local scale = if someReallyLongConditionName\n    or someOtherReallyLongConditionName\n    then Vector2.new(1, 1) + someVectorOffset\n        + someOtherVector\n    else Vector2.new(1, 1) + someNewVectorOffset\n        + someNewOtherVector\n</code></pre></li> <li>An exception to the above is if the <code>if</code> expression is in the middle of a much larger expression (e.g. a table definition or function call) and converting it to a normal <code>if</code> statement would involve copying a large number of lines.     <p>Good:</p> <pre><code>local thing = makeSomething(\"Foo\", {\n    OneChild = if someCondition\n        then makeSomething(\"Bar\", {\n            scale = 1,\n        })\n        else makeSomething(\"Bar\", {\n            scale = 2,\n        }),\n    TwoChild = makeSomething(\"Baz\"),\n})\n</code></pre> <p>Bad:</p> <pre><code>local thing = makeSomething(\"Foo\", {\n    OneChild = if someCondition then\n        makeSomething(\"Bar\", {\n            scale = 1,\n        })\n    else\n        makeSomething(\"Bar\", {\n            scale = 2,\n        }),\n    TwoChild = makeSomething(\"Baz\"),\n})\n\nlocal thing = makeSomething(\"Foo\", {\n    OneChild = if someCondition then makeSomething(\"Bar\", {\n        scale = 1,\n    }) else makeSomething(\"Bar\", {\n        scale = 2,\n    }),\n    TwoChild = makeSomething(\"Baz\"),\n})\n</code></pre></li> <li>If the condition itself is too long to fit on one line, use a helper variable.     <p>Good:</p> <pre><code>local useNewScale = someReallyReallyLongFunctionName()\n    and someOtherReallyLongFunctionName()\nlocal scale = if useNewScale then 1 else 2\n</code></pre> <p>Bad:</p> <pre><code>local scale = if someReallyReallyLongFunctionName()\n    and someOtherReallyLongFunctionName()\n    then 1\n    else 2\n</code></pre></li> <li> <p>While <code>if</code> expressions do support <code>elseif</code>, it should be used sparingly. If your set of conditions is complicated enough to need several elseifs, then it may be difficult to read as a single expression. When using an <code>if</code> expression that includes <code>elseif</code> clauses is preferred, put the <code>elseif (condition)</code> then on a new line just like <code>then</code> and <code>else</code>.</p> <ul> <li>This is a tradeoff. It would be more consistent to put the second then on a newline indented again, but then you end up deeply indented, which isn't good.</li> </ul> <pre><code>local scale = if someCondition then 1 elseif someOtherCondition then 0.5 else 2\n\nlocal thing = makeSomething(\"Foo\", {\n    OneChild = if someCondition\n        then makeSomething(\"Bar\", {\n            scale = 1,\n        })\n        elseif someOtherCondition then makeSomething(\"Bar\", {\n            scale = 0.5,\n        })\n        else makeSomething(\"Bar\", {\n            scale = 2,\n        }),\n    TwoChild = makeSomething(\"Baz\"),\n})\n</code></pre> </li> </ul>"},{"location":"#blocks","title":"Blocks","text":"<ul> <li>Don't use parentheses around the conditions in <code>if</code>, <code>while</code>, or <code>repeat</code> blocks. They aren't necessary in Lua!     <pre><code>if CONDITION then\nend\n\nwhile CONDITION do\nend\n\nrepeat\nuntil CONDITION\n</code></pre></li> <li>Use <code>do</code> blocks if limiting the scope of a variable is useful.     <pre><code>local getId\ndo\n    local lastId = 0\n    getId = function()\n        lastId = lastId + 1\n        return lastId\n    end\nend\n</code></pre></li> </ul>"},{"location":"#literals","title":"Literals","text":"<ul> <li>Use double quotes when declaring string literals.<ul> <li>Using single quotes means we have to escape apostrophes, which are often useful in English words.</li> <li>Empty strings are easier to identify with double quotes, because in some fonts two single quotes might look like a single double quote (<code>\"\"</code> vs <code>''</code>). <p>Good:</p> <pre><code>print(\"Here's a message!\")\n</code></pre> <p>Bad:</p> <pre><code>print('Here\\'s a message!')\n</code></pre></li> <li>Single quotes are acceptable if the string contains double quotes to reduce escape sequences. <p>Exception:</p> <pre><code>print('Quoth the raven, \"Nevermore\"')\n</code></pre></li> <li>If the string contains both single and double quotes, prefer double quotes on the outside, but use your best judgement.</li> </ul> </li> </ul>"},{"location":"#tables","title":"Tables","text":"<ul> <li>Avoid tables with both list-like and dictionary-like keys.<ul> <li>Iterating over these mixed tables is troublesome.</li> </ul> </li> <li>Don't specify <code>pairs</code> or <code>ipairs</code> as the iterator when iterating over a table. Luau supports <code>for key, value in table</code> syntax, which is generally more readable.<ul> <li>The argument that this helps clarify what kind of table we're expecting is irrelevant with types annotations.</li> </ul> </li> <li>Add trailing commas in multi-line tables.<ul> <li>This lets us re-sort lines with a single keypress (Alt+Up and Alt+Down). <pre><code>local frobs = {\n    andrew = true,\n    billy = true,\n    caroline = true,\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"#functions","title":"Functions","text":"<ul> <li>Keep the number of arguments to a given function small, preferably 1 or 2.</li> <li>Always use parentheses when calling a function. Luau allows you to skip them in many cases, but the results are typically much harder to parse.     <p>Good:</p> <pre><code>local x = doSomething(\"home\")\nlocal y = doSomethingElse({u = 1, v = 2})\n</code></pre> <p>Bad:</p> <pre><code>local x = doSomething \"home\"\nlocal y = doSomethingElse{u = 1, v = 2}\n</code></pre>     Of particular note, the last example - using the curly braces as if they were function call syntax - is common in other Lua codebases, but while it's more readable than other ways of using this feature, for consistency we don't use it in our codebase.</li> <li>Declare named functions using function-prefix syntax. Non-member functions should always be local.     <p>Good:</p> <pre><code>local function add(a, b)\n    return a + b\nend\n</code></pre> <p>Bad:</p> <pre><code>-- This is a global!\nfunction add(a, b)\n    return a + b\nend\n\nlocal add = function(a, b)\n    return a + b\nend\n</code></pre> <p>Exception:</p> <pre><code>-- An exception can be made for late-initializing functions in conditionals:\nlocal doSomething\n\nif CONDITION then\n    function doSomething()\n        -- Version of doSomething with CONDITION enabled\n    end\nelse\n    function doSomething()\n        -- Version of doSomething with CONDITION disabled\n    end\nend\n</code></pre><ul> <li>When declaring a function inside a table, use function-prefix syntax. Differentiate between <code>.</code> and <code>:</code> to denote intended calling convention.     <p>Good:</p> <pre><code>-- This function should be called as Frobulator.new()\nfunction Frobulator.new()\n    return {}\nend\n\n-- This function should be called as Frobulator:frob()\nfunction Frobulator:frob()\n    print(\"Frobbing\", self)\nend\n</code></pre> <p>Bad:</p> <pre><code>function Frobulator.garb(self)\n    print(\"Frobbing\", self)\nend\n\nFrobulator.jarp = function()\n    return {}\nend\n</code></pre></li> </ul> </li> </ul>"},{"location":"#comments","title":"Comments","text":"<ul> <li>Wrap comments to 80 columns wide.<ul> <li>It's easier to read comments with shorter lines, but fitting code into 80 columns can be challenging.</li> </ul> </li> <li> <p>Use single line comments for inline notes:</p> <ul> <li>If the comment spans multiple lines, use multiple single-line comments.</li> <li>VS Code has an automatic wrap feature (Alt+Z on Windows) to help with this.</li> </ul> <p><pre><code>-- This condition is really important because the world would blow up if it\n-- were missing.\nif not foo then\n    stopWorldFromBlowingUp()\nend\n</code></pre> - Use block comments for documenting items: - Use a block comment at the top of files to describe their purpose. - Use a block comment before functions or objects to describe their intent.</p> <p><pre><code>--[[\n    Shuts off the cosmic moon ray immediately.\n\n    Should only be called within 15 minutes of midnight Mountain Standard\n    Time, or the cosmic moon ray may be damaged.\n]]\nlocal function stopCosmicMoonRay()\nend\n</code></pre> - Comments should focus on why code is written a certain way instead of what the code is doing. <p>Good:</p> <pre><code>-- Without this condition, the aircraft hangar would fill up with water.\nif waterLevelTooHigh() then\n    drainHangar()\nend\n</code></pre> <p>Bad:</p> <pre><code>-- Check if the water level is too high.\nif waterLevelTooHigh() then\n    -- Drain the hangar\n    drainHangar()\nend\n</code></pre></p> </li> <li> <p>No section comments.</p> <p>Comments that only exist to break up a large file are a code stink; you probably need to find some way to make your file smaller instead of working around that problem with section comments. Comments that only exist to demark already obvious groupings of code (e.g. --- VARIABLES ---) and overly stylized comments can actually make the code harder to read, not easier. Additionally, when writing section headers, you (and anyone else editing the file later) have to be thorough to avoid confusing the reader with questions of where sections end.</p> <p>Some examples of ways of breaking up files:</p> <ul> <li>Move inner classes and static functions into their own files, which aren't included in the public API. This also makes testing those classes and functions easier.</li> <li>Check if there are any existing libraries that can simplify your code. If you're writing something and think that you could make part of this into a library, there's a good chance someone already has.</li> </ul> <p>If you can't break the file up, and still feel like you need section headings, consider these alternatives.</p> <ul> <li> <p>If you want to put a section header on a group of functions, put that information in a block comment attached to the first function in that section. You should still make sure the comment is about the function its attached to, but it can also include information about the section as a whole. Try and write the comment in a way that makes it clear what's included in the section.</p> <pre><code>--[[\n    All of the readX functions return the next token from the string\n    passed in to the Reader or returns nil if the next token doesn't\n    match the type the function is trying to read.\n\n    local test = \"123 ABC\"\n    i = reader:readInt()\n    print(i, \",\", test.remaining) -- 123 , ABC\n\n    readInt reads an integer, positive or negative.\n]]\nfunction Reader:readInt() -- ...\n\n-- readFloat reads a floating point number, but does not accept\n-- scientific notation\nfunction Reader:readFloat() -- ...\n</code></pre> </li> <li> <p>The same can be done for a group of variables in some cases. All the same caveats apply though, and you have to consider whether one block comment or a normal comment on each variable (or even using just whitespace to separate groups) would be more readable.</p> </li> <li>General organization of your code can aid readability while making logical sections more obvious as well. Module level variables and functions can appear in any order, so you can sometimes put a group of variables above a group of functions to make a section.</li> </ul> </li> </ul>"},{"location":"#naming","title":"Naming","text":"<ul> <li>Spell out words fully! Abbreviations generally make code easier to write, but harder to read.</li> <li>Use <code>PascalCase</code> names for class and enum-like objects.</li> <li>Use <code>PascalCase</code> for all Roblox APIs. <code>camelCase</code> APIs are mostly deprecated, but still work for now.</li> <li>Use <code>camelCase</code> names for local variables, member values, and functions.</li> <li>For acronyms within names, don't capitalize the whole thing. For example, <code>aJsonVariable</code> or <code>MakeHttpCall</code>.</li> <li>The exception to this is when the abbreviation represents a set. For example, in <code>anRGBValue</code> or <code>GetXYZ</code>. In these cases, RGB should be treated as an abbreviation of <code>RedGreenBlue</code> and not as an acronym.</li> <li>Use <code>LOUD_SNAKE_CASE</code> names for local constants.</li> <li>Prefix private members with an underscore, like <code>_camelCase</code>.<ul> <li>Luau does not have visibility rules, but using a character like an underscore helps make private access stand out.</li> </ul> </li> <li>A file's name should match the name of the object it exports.<ul> <li>If your module exports a single function named <code>doSomething</code>, the file should be named <code>doSomething</code>.</li> </ul> </li> </ul> <p><code>FooThing</code>: <pre><code>local FOO_THRESHOLD = 6\n\nlocal FooThing = {}\n\nFooThing.someMemberConstant = 5\n\nfunction FooThing.go()\n    print(\"Foo Delta:\", FooThing.someMemberConstant - FOO_THRESHOLD)\nend\n\nreturn FooThing\n</code></pre></p>"},{"location":"#types","title":"Types","text":"<ul> <li>Always give a type to uninitialised variables.      <p>Good:</p> <pre><code>local currentPosition: Vector3\n</code></pre> <p>Bad:</p> <pre><code>local currentPosition\n</code></pre></li> <li> <p>Use type annotations on all function arguments and return values.     <p>Good:</p> <pre><code>local function doSomething(position: Vector3): number\n    return position.X + position.Y + position.Z\nend\n</code></pre> <p>Bad:</p> <pre><code>-- Here, when using auto-complete, no argument or return type is shown.\nlocal function doSomething(position)\n    return position.x + position.y + position.z\nend\n</code></pre></p> <ul> <li>Luau can infer function argument and return types in certain situations, but it's best to be explicit.</li> </ul> </li> </ul>"},{"location":"#error-handling","title":"Error Handling","text":"<p>When writing functions that can fail, return <code>success, result</code>, use a <code>Result</code> type, or use an async primitive that encodes failure, like <code>Promise</code>.</p> <p>Do not throw errors except when validating correct usage of a function. <pre><code>local function thisCanFail(someValue: string): boolean, string\n    assert(typeof(someValue) == \"string\", \"someValue must be a string!\")\n\n    if success() then\n        return true, \"Congratulations! You won!\"\n    else\n        return false, Error.new(\"ERR_BLAH\", \"Something horrible failed!\")\n    end\nend\n</code></pre></p>"},{"location":"#pros","title":"Pros:","text":"<ul> <li>Using exceptions lets unhandled errors bubble up 'automatically' to your caller.</li> <li>Stack traces are automatically attached to errors.</li> </ul>"},{"location":"#cons","title":"Cons:","text":"<ul> <li>Luau can only throw strings as errors, which makes distinguishing between them very difficult.</li> <li>Exceptions are not encoded into a function's contract explicitly. By returning <code>success, result</code>, you force your caller to consider whether an error will happen.</li> </ul>"},{"location":"#exceptions","title":"Exceptions:","text":"<ul> <li>When calling functions that communicate failure by throwing, wrap calls in pcall and make it clear via comment what kinds of errors you're expecting to handle.</li> </ul>"}]}